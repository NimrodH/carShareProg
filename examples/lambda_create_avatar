# will get the data that user entered in the welcomMessage and
# CREATE line for the avatar in the signs table
#  and will get the position of the avatar from the urls table
#  and will lock the position in the urls table
#  create the avatar in the avatars table
#  and will return the position and URL of the avatar to the user


import json
import time
import boto3
import os
from botocore.exceptions import ClientError
#from decimal import Decimal

#class DecimalEncoder(json.JSONEncoder):
#    def default(self, obj):
#        if isinstance(obj, Decimal):
#            return float(obj)
#        return super(DecimalEncoder, self).default(obj)

#TODO: set 'API_GATEWAY_ENDPOINT'] & 'URLS_TABLE_NAME' & AVATARS_TABLE_NAME & SIGNS_TABLE_NAME
dynamodb = boto3.resource('dynamodb')
dynamodb_client = boto3.client('dynamodb')
#apigatewaymanagementapi = boto3.client('apigatewaymanagementapi', endpoint_url=os.environ['API_GATEWAY_ENDPOINT'])
urls_table = dynamodb.Table(os.environ['URLS_TABLE_NAME'])
avatars_table = dynamodb.Table(os.environ['AVATARS_TABLE_NAME'])
signs_table = dynamodb.Table(os.environ['SIGNS_TABLE_NAME'])
MAX_RETRIES = 50  # Maximum number of retries if an item is locked
RETRY_DELAY = 2  # Delay in seconds between retries


def lambda_handler(event, context):
    print('Received event:', json.dumps(event, indent=2))
    # TODO implement
    connection_id = event['requestContext']['connectionId']
    ### retrieve from the event body the data that user entered to welcome message
    body = json.loads(event['body'])
    print(body)
    avatarID = body.get('ID')
    if avatarID is None:
        print("Error: 'ID' key is missing in the body.")
        return {
            'statusCode': 400,
            'body': json.dumps({'message': "'ID' key is missing in the body"})
        }
    save_sign_data(body, avatarID)
    avatar_pos_url = find_and_lock_item()
    if avatar_pos_url:
        print(f"Locked item details: {avatar_pos_url}")
    else:
        print("Could not find or lock any item.")
        return {
            'statusCode': 400,
            'body': json.dumps({'message': 'Could not find or lock any item'})
    }
    write_avatar(avatarID, avatar_pos_url, connection_id)
    print('Avatar created successfully')
    message = { "action" : "createAvatar", "avatarDetails" : avatar_pos_url, "signData": body }
    response = send2client(connection_id, message)
    return {
        'statusCode': 200,
        'body': json.dumps({'message': 'Avatar created successfully'})
    }

def save_sign_data(body, avatarID):
    sign_data = {
        'isMan': body['isMan'],
        'address': body['address'],
        'day1to': body['day1to'],
        'day1back': body['day1back'],
        'day2to': body['day2to'],
        'day2back': body['day2back'],
        'day3to': body['day3to'],
        'day3back': body['day3back'],
        'day4to': body['day4to'],
        'day4back': body['day4back'],
        'day5to': body['day5to'],
        'day5back': body['day5back']
    }
    
    ### create line for the avatar in the signs table
    put_params = {
        'TableName': signs_table.name,
        'Item': {
            'avatarID': avatarID,
            **sign_data
        }
    }

    try:
        ### Save the item to DynamoDB
        signs_table.put_item(Item=put_params['Item'])
    except Exception as error:
        print(f"Error saving data: {error}")
        return {
            'statusCode': 500,
            'body': json.dumps({'message': 'Failed to save sign data'})
        }
        
     #################
 
 ##############

    ### create line for the avatar in the avatars table
def write_avatar(avatarID, avatar_pos_url, connection_id):
    avatar_params = {
        'TableName': avatars_table.name,
        'Item': {
            'avatarID': avatarID,
            'x': avatar_pos_url["x"],
            'y': avatar_pos_url["y"],
            'z': avatar_pos_url["z"],
            'targetX': avatar_pos_url["targetX"],
            'targetY': avatar_pos_url["targetY"],
            'targetZ': avatar_pos_url["targetZ"],
            'isTalking': False,
            'driveAgreed': False,
            'connectionID': connection_id,
            'avatarURL': avatar_pos_url["URL"]
        }
    }
    try:
        ### Save the item to the avatars table in DynamoDB
        avatars_table.put_item(Item=avatar_params['Item'])
    except Exception as error:
        print(f"Error saving data: {error}")
        return {
            'statusCode': 500,
            'body': json.dumps({'message': 'Failed to save avatar data'})
        }
 
    ###get one of the free items in URLs & palaces table
def get_unlocked_item():
    oneFreePosURL = urls_table.query(
        IndexName='isUsed-num-index',  # Ensure you have a GSI on 'isUsed' attribute
        KeyConditionExpression='isUsed = :false',
        ExpressionAttributeValues={':false': 'false'},  # Use 'false' as a string
        Limit=1  # Only fetch one unlocked item
    )
    items = oneFreePosURL.get('Items', [])
    return items[0] if items else None
 
def lock_item(unlocked_item_id):
    if unlocked_item_id is None:
        print("Item ID is None, cannot lock item.")
        return False

    try:
        dynamodb_client.transact_write_items(
            TransactItems=[
                {
                    'Update': {
                        'TableName': urls_table.name,
                         'Key': {
                            'num': {'S': unlocked_item_id}
                        },
                        'UpdateExpression': 'SET isUsed = :true',
                        'ConditionExpression': 'attribute_not_exists(isUsed) OR isUsed = :false',
                        'ExpressionAttributeValues': {
                            ':true': {'S': 'true'},
                            ':false': {'S': 'false'}
                        }
                    }
                }
            ]
        )
        return (True, None)
    except dynamodb_client.exceptions.TransactionCanceledException as e:
        print("TransactionCanceledException:")
        print(e)
        if 'CancellationReasons' in e.response:
            for reason in e.response['CancellationReasons']:
                print(json.dumps(reason, indent=2))
        return (False, str(e))
    except Exception as e:
        print("Unexpected error:")
        print(e)
        return (False, str(e))

def find_and_lock_item(): 
    retries = 0
    while retries < MAX_RETRIES:
        # Attempt to fetch an unlocked item from the URLs table
        item = get_unlocked_item()
        print("lock_item:")
        print(item)
        if not item:
            print("No available unlocked items found in the URLs table.")
            return None

        unlocked_item_id = item['num']#['S']
        print(f"Trying to lock item: {unlocked_item_id}")

        # Attempt to lock the item
        success, error_message = lock_item(unlocked_item_id)
        if success:
            print(f"Item {unlocked_item_id} locked successfully!")
            return item
        
        # If locking failed, wait and retry
        retries += 1
        print(f"Retrying... ({retries}/{MAX_RETRIES})")
        time.sleep(RETRY_DELAY)
    
    print("Max retries reached. Unable to lock an item.")
    return None

def send2client(connection_id, the_body):
    apigatewaymanagementapi = boto3.client('apigatewaymanagementapi', endpoint_url=os.getenv('API_GATEWAY_ENDPOINT'))
    if connection_id:
        try:
            response = apigatewaymanagementapi.post_to_connection(
                ConnectionId=connection_id,
                Data=json.dumps(the_body)
            )
            return {'statusCode': 200, 'body': json.dumps({'message': 'Message sent successfully'})}
        except ClientError as error:
            print('Error sending message: %s', error)
            return {'statusCode': 500, 'body': json.dumps({'message': 'Failed to send message'})}